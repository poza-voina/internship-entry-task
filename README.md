# Описание проекта

Это REST API для игры в крестики-нолики, реализованное на платформе .NET.

## Условия игры

1. Играют два игрока.
2. Каждый третий ход существует вероятность 10%, что поставленный игроком символ будет заменён на символ противника.

# Сценарий использования
POST /api/v1/game -> запомнить joinKey
POST /api/v1/game/join -> запомнить accessKey

Чтобы посмотреть на доску в виде двумерного массива нужно передавать заголовок X-ShowBoard


## Архитектура

Проект построен на основе слоистой архитектуры и состоит из следующих сборок:

### 1. `InternshipEntryTask.Api` — API-слой

Отвечает за обработку HTTP-запросов и делегирование выполнения бизнес-логики слоям ниже. 
Для реализации Etag был использован MemmoryCash.

Особенности:
- Реализован глобальный обработчик исключений (`ExceptionHandler`), который преобразует исключения в `ProblemDetails`.

### 2. `InternshipEntryTask.Core` — бизнес-логика

Содержит основную игровую логику:
- Сервисы для управления состоянием игры;
- Фабрика для генерации и оценки игровой доски;
- Правила игры.

### 3. `InternshipEntryTask.Infrastructure` — инфраструктурный слой

Отвечает за работу с базой данных:
- Контекст Entity Framework Core;
- Конфигурации моделей;
- Репозитории и взаимодействие с БД.

## Тестирование

### Интеграционные тесты

Используемые библиотеки: `xUnit`, `FluentAssertions`, `Microsoft.TestPlatform`, `TestContainers`.

Проблема:
- Возникла задача изолировать данные при запуске тестов в одном Docker-контейнере, закреплённом за классом.

Решение:
- Использование отдельных схем базы данных PostgreSQL на каждый тест. Это позволило запускать тесты независимо и параллельно.

### Юнит-тесты

Библиотеки те же, за исключением `TestContainers`. Покрывает логику работы  `GameBoardEvaluator`

## ТЗ
[x] Создание новой игры,
[x] Ходы двух игроков,
[x] Фиксация победы или ничьей.
[x] Размер поля и условия победы задаются через переменные окружения
[x] Платформа: .NET 9
[x] В репозитории есть Dockerfile (обязательно) и при необходимости docker-compose.yml.
[x] Приложение внутри контейнера слушает порт 8080.
[x] На запрос GET /health отвечает 200 OK.
[x] Есть интеграционные и unit тесты
[x] Минимальное покрытие кода — 30 %.
[x] Запуск тестов в CI и локально — dotnet test (или аналогичная команда).
[x] При гонке двух POST /moves с одинаковым телом второй запрос обязан вернуть 200 OK и тот же ETag.
[x] После перезапуска контейнера мы выполняем GET /games/{id} и делаем следующий ход. Сессия игрока сохраняется.
[x] Любой некорректный JSON (пример ниже) → HTTP 400 (RFC 7807)